using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using FluentResults;
using Microsoft.Extensions.DependencyInjection;

namespace OoLunar.HyperSharp.Responders
{
    /// <summary>
    /// Locator for finding and compiling responders.
    /// </summary>
    public sealed class ResponderLocator
    {
        private readonly IServiceCollection serviceCollection;

        /// <summary>
        /// Initializes a new instance of the <see cref="ResponderLocator"/> class.
        /// </summary>
        /// <param name="serviceCollection">The service collection for dependency injection.</param>
        public ResponderLocator(IServiceCollection serviceCollection) => this.serviceCollection = serviceCollection ?? throw new ArgumentNullException(nameof(serviceCollection));

        /// <summary>
        /// Locates and registers the responders from the specified assembly.
        /// </summary>
        /// <param name="assembly">The assembly to search for responders.</param>
        public void LocateResponders(Assembly assembly) => LocateResponders(GetResponderTypes(assembly.GetTypes()));

        /// <summary>
        /// Locates and registers the responders from the specified types.
        /// </summary>
        /// <param name="types">The types to search for responders.</param>
        public void LocateResponders(IEnumerable<Type> types)
        {
            foreach (Type responderType in GetResponderTypes(types))
            {
                CreateResponderSingleton(responderType);
            }
        }

        private static IEnumerable<Type> GetResponderTypes(IEnumerable<Type> types) => types
            .Where(type => typeof(IResponder).IsAssignableFrom(type) && !type.IsInterface);

        private void CreateResponderSingleton(Type responderType) => serviceCollection
            .AddSingleton(typeof(IResponder), responderType)
            .BuildServiceProvider()
            .CreateScope()
            .ServiceProvider
            .GetRequiredService<IResponder>();

        /// <summary>
        /// Compiles the responder path by ordering and grouping the responders based on their dependencies.
        /// </summary>
        /// <returns>A delegate representing the compiled responder path.</returns>
        public Func<HyperContext, Task<Result<HyperStatus>>> CompileResponderPath()
        {
            List<Func<HyperContext, Task<Result<HyperStatus>>>> responderGroups = GetResponderGroups();
            return async (context) =>
            {
                foreach (Func<HyperContext, Task<Result<HyperStatus>>> responderGroup in responderGroups)
                {
                    Result<HyperStatus> result = await responderGroup(context);

                    if (result.IsFailed)
                    {
                        // Log or handle the failure if needed
                        continue;
                    }

                    if (result.Value != default)
                    {
                        // Send the response to the client if needed
                        return result;
                    }
                }

                // No response generated by any responder
                return Result.Fail<HyperStatus>("No responder generated a response.");
            };
        }

        private List<Func<HyperContext, Task<Result<HyperStatus>>>> GetResponderGroups()
        {
            List<IResponder> responders = serviceCollection
                .BuildServiceProvider()
                .GetServices<IResponder>()
                .ToList();

            Dictionary<string, IResponder> responderMap = new();
            List<Func<HyperContext, Task<Result<HyperStatus>>>> responderGroups = new();

            // Create a map of responders by their full names for easy lookup
            foreach (IResponder responder in responders)
            {
                responderMap[responder.GetType().FullName!] = responder;
            }

            // Iterate over the responders to create groups based on their dependencies
            foreach (IResponder responder in responders)
            {
                List<IResponder> group = new();
                BuildResponderGroup(responder, responderMap, group, new HashSet<string>());

                responderGroups.Add(async (context) =>
                {
                    foreach (IResponder r in group)
                    {
                        Result<HyperStatus> result = await r.RespondAsync(context);

                        if (result.IsFailed)
                        {
                            // Log or handle the failure if needed
                            break;
                        }

                        if (result.Value != default)
                        {
                            // Send the response to the client if needed
                            return result;
                        }
                    }

                    // No response generated by any responder in the group
                    return Result.Fail<HyperStatus>("No responder generated a response.");
                });
            }

            return responderGroups;
        }

        private void BuildResponderGroup(IResponder responder, Dictionary<string, IResponder> responderMap, List<IResponder> group, HashSet<string> visited)
        {
            string? responderFullName = responder.GetType().FullName ?? throw new ArgumentException("Responder type has no full name.", nameof(responder));
            if (visited.Contains(responderFullName))
            {
                throw new InvalidOperationException($"Recursive dependency detected for responder: {responderFullName}");
            }

            visited.Add(responderFullName);
            if (responder.DependsOn is not null && responder.DependsOn.Length > 0)
            {
                foreach (string dependencyName in responder.DependsOn)
                {
                    if (!responderMap.TryGetValue(dependencyName, out IResponder? dependency))
                    {
                        throw new Exception($"Missing dependency '{dependencyName}' for responder: {responderFullName}");
                    }

                    BuildResponderGroup(dependency, responderMap, group, visited);
                }
            }

            group.Add(responder);
        }
    }
}
